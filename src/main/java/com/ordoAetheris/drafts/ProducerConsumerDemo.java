package com.ordoAetheris.drafts;

import com.ordoAetheris.drafts.solution.WorkQueue;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class ProducerConsumerDemo {
    public static void main(String[] args) throws Exception {
        // =====================================================================
        // СЦЕНАРИЙ (прод-аналоги):
        // - Producers: компоненты, которые генерируют работу (например, чтение из сокета,
        //   парсинг файлов, прием HTTP запросов, обработка входящих событий Kafka).
        // - WorkQueue: очередь между "приемом" и "обработкой".
        // - Consumers: воркеры, которые выполняют тяжелую обработку (IO/CPU).
        //
        // Ключевые задачи продового сценария:
        // 1) Развязать скорость входа и скорость обработки (producer может быть быстрее).
        // 2) Корректно завершиться (graceful shutdown):
        //    - producers закончили -> очередь закрылась -> consumers не повисли в take()
        // 3) Не потерять работу (produced == consumed).
        // =====================================================================
        WorkQueue<Integer> q = new WorkQueue<>();

        int producers = 2;
        int consumers = 3;
        int perProducer = 50_000;

        // =====================================================================
        // ЭМУЛИРУЕМ: пул потоков сервиса, где часть потоков - producers,
        // часть - consumers. В реальности обычно consumers - отдельный пул,
        // но для демо так проще.
        // =====================================================================
        ExecutorService pool = Executors.newFixedThreadPool(producers + consumers);

        // =====================================================================
        // ЭМУЛИРУЕМ: бизнес-метрику "сколько задач реально обработано".
        // (В проде это будет метрика/счетчик в Prometheus.)
        // =====================================================================
        AtomicInteger consumed = new AtomicInteger();

        // =====================================================================
        // БЛОК 1. Запускаем consumers:
        // ЭМУЛИРУЕМ: воркеры в фоне, которые бесконечно берут из очереди и обрабатывают.
        // Реальный аналог: "worker loop".
        //
        // Важное: корректный выход по close() — take() возвращает null.
        // =====================================================================
        for (int c = 0; c < consumers; c++) {
            pool.submit(() -> {
                try {
                    while (true) {
                        Integer x = q.take();
                        // ВАЖНО - take() - Это не обработка задачи, это просто получение данных из прода, как например
                        // в consumer кафка, в реальной ситуации следующим вызовом идёт метод-обработчик полученных данных
                        // ПРИМЕР handlerService.handle(x)
                        // ЭМУЛИРУЕМ: graceful shutdown — очередь закрыта и пуста => выходим
                        if (x == null) return; // closed + empty
                        // обработка
                        consumed.incrementAndGet();
                    }
                } catch (InterruptedException e) {
                    // ЭМУЛИРУЕМ: остановку сервиса через interrupt (например при shutdownNow())
                    Thread.currentThread().interrupt();
                }
            });
        }
        // =====================================================================
        // БЛОК 2. Запускаем producers:
        // ЭМУЛИРУЕМ: генерацию задач, например чтение событий.
        // Каждый producer кладет уникальный диапазон ID, чтобы можно было проверять корректность.
        // =====================================================================

        // =====================================================================
        // БЛОК 2. Запускаем producers:
        // ЭМУЛИРУЕМ: генерацию задач, например чтение событий.
        // Каждый producer кладет уникальный диапазон ID, чтобы можно было проверять корректность.
        // =====================================================================
        Future<?>[] prodFutures = new Future<?>[producers];
        for (int p = 0; p < producers; p++) {
            final int producerId = p;
            final int base = p * perProducer;

            prodFutures[p] = pool.submit(() -> {
                for (int i = 0; i < perProducer; i++) {
                    q.put(base + i);
                }
                System.out.println("producer-" + producerId + ": finished");
            });
        }

        // =====================================================================
        // БЛОК 3. Ждем producers:
        // ЭМУЛИРУЕМ: сервис дождался, пока источник данных "иссяк" (EOF),
        // либо мы получили сигнал завершения, и после этого переходим к закрытию очереди.
        // =====================================================================
        for (Future<?> f : prodFutures) {
            f.get(10, TimeUnit.SECONDS);
        }
        // =====================================================================
        // БЛОК 4. Закрываем очередь:
        // ЭМУЛИРУЕМ: "больше задач не будет". Это важно: consumers, которые стоят в take(),
        // должны проснуться и выйти, а не зависнуть навсегда.
        // =====================================================================
        q.close();
        System.out.println("main: queue closed");

        // =====================================================================
        // БЛОК 5. Остановка пула:
        // ЭМУЛИРУЕМ: корректное завершение приложения (graceful shutdown).
        // =====================================================================
        pool.shutdown();
        if (!pool.awaitTermination(5, TimeUnit.SECONDS)) {
            // Если кто-то завис — это уже сигнал проблемы.
            pool.shutdownNow();
        }

        int expected = producers * perProducer;
        System.out.println("main: consumed=" + consumed.get() + ", expected=" + expected);
    }
}